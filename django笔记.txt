2. 内容回顾
    python基础
    网络编程
    并发编程
    前端
    数据库

    OSI七层模型
    应用层
    表示层             应用层             HTTP
    会话层
    传输层             传输层             提供端口对端口会话的维护
    网络层             网络层             IP选择和路由选择
    数据链路层         数据链路层          ARP协议
    物理层             物理层

    socket 套接字 是应用层和传输层之间一个虚拟层,是一个接口.

    博客园(socket服务端)
        1. 绑定ip和端口
        2. 监听
        3. 等待连接
        6. 接收数据
        7. 返回数据
        断开连接
                        import socket
                        sk = socket.socket()
                        sk.bind('127.0.0.1',80)
                        sk.listen()
                        conn,addr = sk.accept()
                        msg = conn.recv(1024).decode('utf-8')
                        conn.send(msg.encode('utf-8'))


    浏览器(socket客户端)
        4. 连接服务器
        5. 发送数据
        8. 接收数据
        断开连接
                        import socket
                        sk = socket.socket()
                        sk.connect(('127.0.0.1',80))
                        sk.send(msg.encode('utf-8'))
                        sk.recv(2048).decode('utf-8')
3. 今日内容
    1. HTTP协议

        1. 请求（浏览器向服务器发送的消息——request）
            格式：
                请求方式 URL 协议版本\r\n
                k1: v1\r\n
                k2:v2\r\n
                \r\n
                请求体（请求数据）       可以有可以没有    GET请求没有请求数据

        2. 响应（服务器向浏览器返回的消息——response）
            格式：
                “协议版本 状态码 状态描述符\r\n
                k1: v1\r\n
                k2:v2\r\n
                Content-Type:text/html;charset=utf-8\r\n
                \r\n
                响应体 （HTML代码）”


    2. web框架
        本质: socket服务端

        功能:
            a. socket收发消息
            b. URL和函数的对应关系,根据不同的URL执行不同的函数,返回函数的结果
            c. 读取HTML文件,进行了一个字符替换(模板渲染)

        分类:
            Django flask tornado
            完成了a,b,c三个功能的  ——》 tornado
            完成了b,c 两个功能     ——》 Django
            完成了b 一个功能       ——》 flask

        另一种分类：
            1. Django       大而全
            2. 其他       短小精悍

         一个请求的完整的流程：
        1. web服务要启动，等待连接；
        2. 在浏览器地址栏中输入URL，回车。向服务器发送一个遵循HTTP协议的GET请求。
        3. 服务器收到请求，按照HTTP协议去解析请求。拿到URL，找到对应的函数。
        4. 函数中处理HTML代码，进行字符串的替换。拿到一个新的字符串。
        5. 服务器把响应体按照HTTP响应的格式组装起来返回给浏览器。
        6. 浏览器接收到数据，拿到响应体渲染。
        7. 断开连接。

1. 下载：
        命令行：
            pip install django==1.11.15
            pip install -i 源 django==1.11.15
        pycharm
            settings 解释器 点+号  输入django 选择版本
    2. 创建django项目
        1. 命令行
            cd 保存项目的目录
            django-admin startproject 项目名
        2. pycharm
            file ——》 new project ——> 选择django  ——> 选择解释器 ——》 创建django项目
    3. 启动项目
        1. 命令行：
            cd manage.py 的目录下
            python manage.py runserver # 127.0.0.1:8000
            python manage.py runserver 80 # 127.0.0.1:80
            python manage.py runserver 0.0.0.0:80 # 0.0.0.0:80
        2. pycharm
            配置项
            点绿色三角启动
    4. settings配置
        1. 静态文件
            STATIC_URL = '/static/'   # 别名
            STATICFILES_DIRS = [
                os.path.join(BASE_DIR,'static'),
                os.path.join(BASE_DIR,'static1'),
            ]
        2. TEMPLATES 模板 HTML文件
            DIRS [os.path.join(BASE_DIR, 'templates')]

        3. INSTALLED_APPS = [
            'app01' ,
            'app01.apps.App01Config'

        ]


        3. 注释csrf中间件 form可以提交POST请求

        4. 数据库的配置

    5. URL和函数的对应关系 ——> urls.py
        urlpatterns = [
            url(r'^admin/', admin.site.urls),
            url(r'^login/', views.login),
            url(r'^index/', views.index),
            url(r'^test/', views.test)
        ]

    6. APP
        1. 创建APP
            1. 命令行
                python manage.py startapp app01
            2. pycharm
                tools ——> run manage.py task ——> startapp app01

        2. 注册APP
            在settings.py中的INSTALLED_APPS写：
            ‘app01’ 或者 'app01.apps.App01Config'


    7. 使用MySQL数据库
        1. 创建一个MySQL数据库
        2. settings的配置：
            DATABASES = {
                'default': {
                    'ENGINE': 'django.db.backends.mysql',   # 引擎
                    'NAME': 'day66',                        # 数据库名
                    'USER':'root',                          # 用户名
                    'PASSWORD':'',                          # 密码
                    'HOST':'127.0.0.1',                     # IP
                    'PORT': 3306,                           # 端口号
                }
            }

        3. 告诉django使用pymysql模块连接数据库
            在settings.py同级目录下的__init__.py中写：
                import pymysql
                pymysql.install_as_MySQLdb()
        4. 建表 在app01/models.py中写类（继承models.Model）
            class Userinfo(models.Model):
                user = models.CharField(max_length=32)  # varchar(32)
                pwd = models.CharField(max_length=32)
        5. 执行数据库迁移命令
            python manage.py makemigrations  # 记录models.py中类是不是有变化 将变化的内容记录下来
            python manage.py migrate         # 将model的变更同步到数据库中

    8. ORM
        对象和关系型数据库的映射  通过操作对象的方式来操作数据库

        映射关系;
            类    —— 》  数据表
            对象  —— 》  数据行
            属性  —— 》  字段

        ORM能做的事：
            操作数据表
            操作数据行

        ORM操作：
            from app01 import models
        增：
            有返回值，为对象本身
            models.Publisher.objects.create(name='新华出版社')

        查：
            查询所有
            models.Publisher.objects.all()   ——》 对象列表Queryset

            获取一个对象，取不到数据或者取到多条数据的时候报错model
            models.Publisher.objects.get(name='新华出版社')   ——》 单独的一个对象

            获取满足条件的对象，没有返回空
            models.Publisher.objects.filter(name='新华出版社') ——》对象列表

        删：
            models.Publisher.objects.filter(name='新华出版社').delete()

            models.Publisher.objects.get(name='新华出版社').delete()

            ret = models.Publisher.objects.all()
            ret[0].delete()

        改：
            obj = models.Publisher.objects.get(name='新华出版社')
            obj.name = '新新华出版社'
            obj.save()



    1. 图书管理系统的表结构设计

        出版社  书  作者

        出版社 书   一对多
        书   作者   多对多



    2. 外键
        描述 多对一的关系
        写在多的一方

        class Book(models.Model):
            title = models.CharField(max_length=32, unique=True)
            publisher = models.ForeignKey(to=Publisher, on_delete=models.CASCADE)
            # publisher = models.ForeignKey(to='Publisher', on_delete=models.CASCADE)


        book_obj.publisher      ——》 书籍关联的对象
        book_obj.publisher_id   ——》 书籍关联的对象id  直接从数据库获取的


        # 设置外键（关联出版社对象） 修改
        book_obj.publisher = 出版社对象
        book_obj.save()

        book_obj.publisher_id = 1
        book_obj.save()

        # 创建
        models.Book.objects.create(title='新的书名',publisher=models.Publisher.objects.get(id=1))
        models.Book.objects.create(title='新的书名',publisher_id=1)


    3. 多对多
        书 和 作者

        class Author(models.Model):
            name = models.CharField(max_length=32, unique=True)
            books = models.ManyToManyField('Book')


        author_obj.books            ——》  不是关联的对象  是管理的对象
        author_obj.books.all()      ——》  获取到跟作者关联的所有书籍对象

        author_obj.books.set([1,2,3,4])         ——》不是author_obj.save()
        author_obj.books.set([1,2])
        author_obj.books.set([3,4])

    4. 模板相关

        if判断
            {% if book in edit_obj.books.all %}
                <option value="{{ book.id }}" selected>{{ book.title }}</option>
            {% else %}
                <option value="{{ book.id }}">{{ book.title }}</option>
            {% endif %}


            {% if 条件1 %}
                操作1
            {% elif 条件2 %}
                操作2
            {% else %}
                操作3
            {% endif %}

        for循环中
            {% for i in name_list %}
                {{ forloop.first }} 第一次循环
                {{ forloop.last }}  最后一次循环
            {% endfor %}

    9. form表单

        1. method='post' action=''  请求方式  提交数据的地址
        2. 所有的input的标签要有name属性
        3. 有一个input的type=‘submit’  或者有一个button按钮

    10. GET 和 POST
        GET:获取一个页面
         ?key1=v1&key2=v2


        POST: 提交数据


        3. GET POST 区别
        GET
            在浏览器地址栏上输入URL 回车
            点击a标签
            form表单不写method

            127.0.0.1:8000/add_publisher/?id=1&name=alex
        POST
            form表达指定method='post'

            数据不可见

    11. views.py  写函数
        request  跟请求相关的所有内容
            request.method   字符串  请示方式 GET/POST
            request.POST     POST请求提交的数据    字典
            request.GET      GET请求提交的数据

        request   ——》 封装请求的所有内容
        request.method    ——》 请求的方式   GET POST
        request.POST      ——》 post请求提交的数据   字典 request.POST['id']  request.POST.get('id',)
        request.GET       ——》 URL的参数
            127.0.0.1:80/del_book/?id=1&name=xxx

        返回值
        from django.shortcuts import HttpResponse,render,redirect

        HttpResponse('字符串')         ——》 页面显示的就是'字符串'
        render(request,'模板文件名')    ——》 渲染你的HTML文件返回给浏览器
        redirect('要跳转的URL')         ——》 重定向  告诉浏览器再向URL再发一次GET请求

            7. 函数的返回值
        HttpResponse('字符串')         ——》 页面显示字符串的内容
        render(request,'模板的名字',{k1:v1})     ——》 整个HTML文件返回给浏览器
        redirect('/index/')             跳转  重定向  响应头  location：/index/


6. 模板相关

        render(request,'模板名字',{'new_name':'新华出版社','err_meg':'出版社已存在'})


        {{ 变量名 }}   {{ new_name}}  新华出版社

        标签
        {% for publisher in publishers %}
            {{ forloop.counter }}
            {{ publisher.id }}
            {{ publisher.name }}
        {% endfor%}


day66
1. 内容回顾
    1. HTTP协议：
        1. 请求（浏览器向服务器发送的消息——request）
            格式：
                请求方式 URL 协议版本\r\n
                k1: v1\r\n
                k2:v2\r\n
                \r\n
                请求体（请求数据）       可以有可以没有    GET请求没有请求数据

        2. 响应（服务器向浏览器返回的消息——response）
            格式：
                “协议版本 状态码 状态描述符\r\n
                k1: v1\r\n
                k2:v2\r\n
                Content-Type:text/html;charset=utf-8\r\n
                \r\n
                响应体 （HTML代码）”
    2. web框架的本质（socket服务端）
        1. socket收发消息
        2. URL和函数的对应关系
        3. 模板渲染（字符串的替换）

    3. 分类
        Django 2 3
        flask  2
        tornado 1 2 3
    4. 一个请求的完整的流程：
        1. web服务要启动，等待连接；
        2. 在浏览器地址栏中输入URL，回车。向服务器发送一个遵循HTTP协议的GET请求。
        3. 服务器收到请求，按照HTTP协议去解析请求。拿到到URL，找到对应的函数。
        4. 函数中处理HTML代码，进行字符串的替换。拿到一个新的字符串。
        5. 服务器把响应体按照HTTP响应的格式组装起来返回给浏览器。
        6. 浏览器接收到数据，拿到响应体渲染。
        7. 断开连接。

    5. Django相关的内容
        1. 下载安装
            1. 命令行
                pip install django==1.11.15
                pip install -i https://pypi.doubanio.com/simple/ django==1.11.15
            2. pycharm


        2. 创建项目
            1. 命令行
                cd 存放项目的目录
                django-admin startproject 项目名
            2. pycharm


        3. 启动项目
            1. 命令行
                cd 有manage.py 的文件目录下
                python manage.py runserver    # 127.0.0.1:8000
                python manage.py runserver 80   # 127.0.0.1:80
                python manage.py runserver 0.0.0.0:80   # 0.0.0.0:80
            2. pycharm

        4. 配置文件
            TEMPLATES 模板     ——》存放HTML文件
            'DIRS': [os.path.join(BASE_DIR, 'templates')]


            STATIC_URL = '/static/'   # 别名
            STATICFILES_DIRS = [
                os.path.join(BASE_DIR, 'static')
            ]


2.今日内容
    1. 登录的完整实例


        form表单提交数据注意事项：
            1. input 标签有name属性
            2. action="" method="post"   提交的地方  提交的方式
            3. 有一个input的type="submit"  或者有一个button按钮

    2. GET 和 POST 的区别
        1. GET
            1. 获取一个页面
            2. 提交数据    数据显示在URL  ?user=alex&pwd=alexdsb

        2. POST
            form表单提交数据   数据不显示


    3. APP

        项目     老男孩

        APP      Python学院  linux学院

    4. 使用MySQL数据库的配置
        1. DATABASES = {
            'default': {
                'ENGINE': 'django.db.backends.mysql', # 引擎
                'NAME': 'day66',                        # 数据库名
                'USER':'root',                          # 用户名
                'PASSWORD':'',                          # 密码
                'HOST':'127.0.0.1',                     # IP
                'PORT': 3306,                            # 端口号
            }
        }
        2. 在与settings.py同级目录下的__init__.py文件中写：
            import pymysql
            pymysql.install_as_MySQLdb()


        3. 创建表：
            在models.py中写类
            class Userinfo(models.Model):
                user = models.CharField(max_length=32)  # varchar(32)
                pwd = models.CharField(max_length=32)

        4. 执行两条命令：
            python manage.py makemigrations    # 把models.py的变化记录下来
            python manage.py migrate           # 去修改你的数据库


    5. ORM操作：
        from login import models
        1.  获取数据表所有内容
            all = models.Userinfo.objects.all()
        2. 获取一条数据
            models.Userinfo.objects.get(user='alex')
            # 没有数据或者多条数据就报错

        3. 向数据库插入一条数据
            models.Userinfo.objects.create(user='alex',pwd='alexdsb')


今日作业：
    1. 整理内容
    2. 课上代码
    3. 登录注册使用ORM。数据放在数据中。

day67
1. 内容回顾：
    1. 下载：
        命令行：
            pip install django==1.11.15
            pip install -i 源 django==1.11.15
        pycharm
            settings 解释器 点+号  输入django 选择版本
    2. 创建django项目
        1. 命令行
            cd 保存项目的目录
            django-admin startproject 项目名
        2. pycharm
            file ——》 new project ——> 选择django  ——> 选择解释器 ——》 创建django项目
    3. 启动项目
        1. 命令行：
            cd manage.py 的目录下
            python manage.py runserver # 127.0.0.1:8000
            python manage.py runserver 80 # 127.0.0.1:80
            python manage.py runserver 0.0.0.0:80 # 0.0.0.0:80
        2. pycharm
            配置项
            点绿色三角启动
    4. settings配置
        1. 静态文件
            STATIC_URL = '/static/'   # 别名
            STATICFILES_DIRS = [
                os.path.join(BASE_DIR,'static'),
                os.path.join(BASE_DIR,'static1'),
            ]
        2. TEMPLATES 模板 HTML文件
            DIRS [os.path.join(BASE_DIR, 'templates')]

        3. 注释csrf中间件

        4. 数据库的配置

    5. URL和函数的对应关系 ——> urls.py
        urlpatterns = [
            url(r'^admin/', admin.site.urls),
            url(r'^login/', views.login),
            url(r'^index/', views.index),
            url(r'^test/', views.test)
        ]

    6. APP
        1. 创建APP
            1. 命令行
                python manage.py startapp app01
            2. pycharm
                tools ——> run manage.py task ——> startapp app01

        2. 注册APP
            在settings.py中的INSTALLED_APPS写：
            ‘app01’ 或者 'app01.apps.App01Config'


    7. 使用MySQL数据库
        1. 创建一个MySQL数据库
        2. settings的配置：
            DATABASES = {
                'default': {
                    'ENGINE': 'django.db.backends.mysql',   # 引擎
                    'NAME': 'day66',                        # 数据库名
                    'USER':'root',                          # 用户名
                    'PASSWORD':'',                          # 密码
                    'HOST':'127.0.0.1',                     # IP
                    'PORT': 3306,                           # 端口号
                }
            }

        3. 告诉django使用pymysql模块连接数据库
            在settings.py同级目录下的__init__.py中写：
                import pymysql
                pymysql.install_as_MySQLdb()
        4. 建表 在app01/models.py中写类（继承models.Model）
            class Userinfo(models.Model):
                user = models.CharField(max_length=32)  # varchar(32)
                pwd = models.CharField(max_length=32)
        5. 执行数据库迁移命令
            python manage.py makemigrations  # 记录models.py中类是不是有变化 将变化的内容记录下来
            python manage.py migrate         # 将model的变更同步到数据库中

    8. ORM
        对象和关系型数据库的映射  通过操作对象的方式来操作数据库

        映射关系;
            类    —— 》  数据表
            对象  —— 》  数据行
            属性  —— 》  字段

        ORM能做的事：
            操作数据表
            操作数据行

        ORM操作：
            from login import models
            # 获取所有数据
            models.Userinfo.objects.all()       ——》 Queryset
            # 获取一条数据
            models.Userinfo.objects.get(user='alex',pwd='alexdsb')
            取不到数据或者取到多条数据的时候报错
            # 创建一条数据
            models.Userinfo.objects.create(user='alex',pwd='alexdsb')

    9. form表单

        1. method='post' action=''  请求方式  提交数据的地址
        2. 所有的input的标签要有name属性
        3. 有一个input的type=‘submit’  或者有一个button按钮

    10. GET 和 POST
        GET:获取一个页面
         ?key1=v1&key2=v2


        POST: 提交数据

    11. views.py  写函数
        request  跟请求相关的所有内容
            request.method   字符串  请示方式 GET/POST
            request.POST     POST请求提交的数据    字典
            request.GET      GET请求提交的数据

        返回值
        from django.shortcuts import HttpResponse,render,redirect

        HttpResponse('字符串')         ——》 页面显示的就是'字符串'
        render(request,'模板文件名')    ——》 渲染你的HTML文件返回给浏览器
        redirect('要跳转的URL')         ——》 重定向  告诉浏览器再向URL再发一次GET请求



2.今日内容
单表的增删改查

3.今天的作业

    1. 课上代码
    2. 用bootstrap改一下

day68
1. 内容回顾
    1. django目前学到的所有命令
        pip install django==1.11.15
        django-admin startproject 项目名
        cd 项目目录下
        python manage.py runserver # 127.0.0.1:8000
        python manage.py runserver 80 # 127.0.0.1:80
        python manage.py runserver 0.0.0.0:80 # 0.0.0.0:80

        python manage.py startapp app名称

        python manage.py makemigrations   # 检查你的app下的models.py是否有变化 有变更将记录到app下的migrations文件夹下
        python manage.py migrate          # 把变更记录更新到数据中
    2. settings.py 中的配置
        1. 注释csrf中间件 form可以提交POST请求
        2. 静态文件
            STATIC_URL = '/static/'  # 别名
            STATICFILES_DIRS = [
                os.path.join(BASE_DIR,'static'),
                os.path.join(BASE_DIR,'static1'),
                os.path.join(BASE_DIR,'static2'),
            ]
        3. 数据库的配置
            ENGINE: 引擎  mysql
            NAME:   数据库名称
            USER:   用户名
            PASSWORD: 密码
            HOST:   IP
            PORT:   端口  3306
        4. INSTALLED_APPS = [
            'app01' ,
            'app01.apps.App01Config'

        ]

        5. TEMPLATES DIRS
            os.path.join(BASE_DIR,'templates')

    3. GET POST
        GET
            在浏览器地址栏上输入URL 回车
            点击a标签
            form表单不写method

            127.0.0.1:8000/add_publisher/?id=1&name=alex
        POST
            form表达指定method='post'

            数据不可见

    4. django使用mysql数据库的流程
        1. 创建一个mysql数据库
        2. 在settings中配置mysql
            DATABASES = {
                'default': {
                    'ENGINE': 'django.db.backends.mysql',
                    'NAME': 'library',
                    'USER': 'root',
                    'PASSWORD': '',
                    'HOST': '127.0.0.1',
                    'PORT': 3306,
                }
            }
        3. 在和settings.py同级目录下__init__.py写代码：
            import pymsql
            pymsql.install_as_MySQLdb()
        4. 在app01/models.py中写类（继承models.Model）
            class Publisher(models.Model):
                id = models.AutoField(primary_key=True)
                name = models.CharField(max_length=32,unique=True)
        5. 执行数据库迁移的命令
            python manage.py makemigrations
            python manage.py migrate

    5. ORM操作
        from app01 import models
        增：
            models.Publisher.objects.create(name='新华出版社')

        查：
            查询所有
            models.Publisher.objects.all()   ——》 对象列表
            获取一个对象
            models.Publisher.objects.get(name='新华出版社')   ——》 单独的一个对象
            获取满足条件的对象
            models.Publisher.objects.filter(name='新华出版社') ——》对象列表
        删：
            models.Publisher.objects.filter(name='新华出版社').delete()

            models.Publisher.objects.get(name='新华出版社').delete()

            ret = models.Publisher.objects.all()
            ret[0].delete()

        改：
            obj = models.Publisher.objects.get(name='新华出版社')
            obj.name = '新新华出版社'
            obj.save()
    6. 模板相关

        render(request,'模板名字',{'new_name':'新华出版社','err_meg':'出版社已存在'})


        {{ 变量名 }}   {{ new_name}}  新华出版社

        标签
        {% for publisher in publishers %}
            {{ forloop.counter }}
            {{ publisher.id }}
            {{ publisher.name }}
        {% endfor%}

2. 今日内容


    1. 图书管理系统的表结构设计

        出版社  书  作者

        出版社 书   一对多
        书   作者   多对多



    2. 外键
        描述 多对一的关系
        写在多的一方

        class Book(models.Model):
            title = models.CharField(max_length=32, unique=True)
            publisher = models.ForeignKey(to=Publisher, on_delete=models.CASCADE)
            # publisher = models.ForeignKey(to='Publisher', on_delete=models.CASCADE)


        book_obj.publisher      ——》 书籍关联的对象
        book_obj.publisher_id   ——》 书籍关联的对象id  直接从数据库获取的


        # 设置外键（关联出版社对象） 修改
        book_obj.publisher = 出版社对象
        book_obj.save()

        book_obj.publisher_id = 1
        book_obj.save()

        # 创建
        models.Book.objects.create(title='新的书名',publisher=models.Publisher.objects.get(id=1))
        models.Book.objects.create(title='新的书名',publisher_id=1)


    3. 多对多
        书 和 作者

        class Author(models.Model):
            name = models.CharField(max_length=32, unique=True)
            books = models.ManyToManyField('Book')


        author_obj.books            ——》  不是关联的对象  是管理的对象
        author_obj.books.all()      ——》  获取到跟作者关联的所有书籍对象

        author_obj.books.set([1,2,3,4])         ——》不是author_obj.save()
        author_obj.books.set([1,2])
        author_obj.books.set([3,4])

    4. 模板相关

        if判断
            {% if book in edit_obj.books.all %}
                <option value="{{ book.id }}" selected>{{ book.title }}</option>
            {% else %}
                <option value="{{ book.id }}">{{ book.title }}</option>
            {% endif %}


            {% if 条件1 %}
                操作1
            {% elif 条件2 %}
                操作2
            {% else %}
                操作3
            {% endif %}

        for循环中
            {% for i in name_list %}
                {{ forloop.first }} 第一次循环
                {{ forloop.last }}  最后一次循环
            {% endfor %}



3. 作业
    1. 课上代码 + bootstrap样式
    2. 学生管理系统
        三个model
            学生
            老师
            班级

        三张表的增删改查



day70
1. 内容回顾
    1. MVC和MTV框架
        1. MVC
            M: model        模型      对数据库进行操作
            V：view          视图    给用户提供页面
            C：controller   控制器    负责调度  传递指令
        2. MTV：
            M: model        模型    ORM 对数据库进行操作
            T：template      模板    对HTML文件进行渲染
            V: view         视图    函数  负责业务逻辑
    2. 模板：
        1. 变量
            {{ 变量名 }}
        2. .的用法
            {{ name_list.0 }}
            {{ name_dict.name1 }}
            {{ p1.name }}
            {{ p1.sing }}
            {{ name_dict.keys }}
            {{ name_dict.values }}
            {{ name_dict.items }}

        3. 过滤器
            1. 语法
                {{ 变量名|filter:参数 }}
            2. 内置的filter
                add:参数          加  数字相加 字符串拼接 列表拼接
                default:参数      变量不存在或者为空  显示默认值
                filesizeformat      人性化显示文件大小  kb  PB
                upper               大写
                lower               小写
                title               首字母大写
                ljust:20            左对齐
                rjust:20            右对齐
                center:20           居中
                length              长度
                slice:'::'          切片
                join:'_'            拼接列表
                first               取第一个元素
                last                取最后一个元素
                safe                取消对HTML代码的转义
                date:'Y-m-d H:i:s'  日期的格式化
                truncatechars:18    文本上的时候进行截断   按18截断

            3. 自定义filter
                1. 在app下创建一个名叫templatetags的python包   templatetags不能错
                2. 在templatetags里建一个py文件   myfilters
                3. 在py文件中编辑：
                    from django import template
                    register = template.Library()     # register名字不能错

                    @register.filter
                    def add_sb(value,arg):
                        return '{}_sb'.format(value)


                    @register.filter(name='dsb')
                    def add_sb(value,arg):
                        return '{}_sb'.format(value)
                4. 重启
                5. 使用filter

                    {% load myfilters %}
                    {{ name1|dsb:'very' }}

2. 今日内容
    1. tags
    2. 母版和继承
        1. 母版
            就是一个普通的HTML文件，提取多个页面的公共部分
            减少代码量  修改十分方便

            定义block块

        2. 使用（继承）
            在子页面中
                {% entends 'base.html' %}
                重新修改block块中的内容
        3. 注意事项：
            1. 把{% extends 'base.html' %} 写在第一行
            2. 修改的内容写在block中，写在外面不显示
            3. {% extends name %}   name应该是变量 或者是字符串  继承母版的名字
            4. 母版中定义多个block块，一般还有 js 块 和 css块



    3. 组件
        1. 就是一小段HTML代码   多个页面都用到的内容 nav.html
        2. 在任意的模板中使用
            {% include 'nav.html' %}



    4. 静态文件相关

        1. {% load staticfiles %} 或者 {% load static %}
        2. {% static 'css/pub.css' %}  ——》 先去settings中获取STATIC_URL的配置，和后面提供的参数进行拼接

        1. {% load static %}
        2.
            <link rel="stylesheet" href="{% get_static_prefix %}css/pub.css">



    5. 自定义simpletag和自定义inclusion_tag
        1. 在app下创建一个名叫templatetags的python包
        2. 在templatetags里建一个py文件
        3. 在py文件中编辑：
            from django import template
            register = template.Library()


            @register.simple_tag
            def join_str(arg1, arg2, arg3,*args,**kwargs):
                print(args)
                print(kwargs)
                return '_'.join([arg1, arg2, arg3])+'*'.join(args)

            @register.inclusion_tag('pagination.html')
            def pagination(total, current):
                return {'total': range(1, total + 1), 'current': current}

        4.使用
            {% load py文件名 %}
            {% 函数名 参数1 参数2 %}



3. 今天的作业
    1. 整理内容
    2. 图书管理系统都使用上模板和组件  尽量较少代码




day71
内容回顾：
    1. tags
        1. for循环
            {% for name in name_list %}
                {{ name }}
            {% endfor %}

            {% for name in name_list %}
                {{ name }}

            {% empty %}
                空空如也

            {% endfor %}

            forloop   {}
                forloop.counter         当前循环的索引值 从1开始
                forloop.counter0        当前循环的索引值 从0开始
                forloop.revcounter      当前循环的索引值  (倒叙) 到1结束
                forloop.revcounter0     当前循环的索引值  (倒叙) 到0结束
                forloop.first           当前循环是否是第一次循环    布尔值
                forloop.last            当前循环是否是最后一次循环   布尔值
                forloop.parentloop      当前循环的外层循环  ——》{}

            上台阶，一次上一个台阶，一次上两个台阶，一次上三个台阶，问有n个台阶有多少种上法？

        2. if判断
            {% if 条件 %}
                操作
            {% endif %}

            {% if 条件 %}
                操作
            {% else %}
                其他操作
            {% endif %}

            {% if 条件 %}
                操作
            {% elif 条件 %}
                不同的操作
            {% else %}
                其他操作
            {% endif %}

            注意的事项：
                1. 不支持连续的判断  a>b>c  and连接
                2. 不支持算数运算   +-*/   使用过滤器

    2. 母版和继承
        为什么用母版和继承？
            多个页面有很多相同或者相似的内容，为了减少代码的重复和修改方便。
        具体步骤：
            1. 写母版 ——》 写一个普通模板（HTML文件）      'base.html'
                把多个页面有相同或者相似的内容提取出来
            2. 在母版中定义多个block块 {% block  block_name %}data{% endblock %}
            3. 写子页面
                1. 继承母版  {% extends 'base.html' %}
                2. 重新写block块中的内容
        注意事项：
            1. {% extends 'base.html' %}写在第一行
            2. 修改的内容写在block中
            3. 一般要定义 block块  js 和 css
            4.  {% extends 'base.html' %}    'base.html'   不加''当成变量

    3. csrf_token
        使用：
            在form标签中使用
        效果：
            在form表单中生成一个隐藏的input  name=csrfmiddlewaretoken  value= 随机字符串
        结果：
            form表单可以提交POST请求

    4.注释  {#  注释的内容  #}

    5.  {% with 变量 as 别名 %}

            {{ 别名 }}

        {% endwith %}

    6. 组件
        把一小部分HTML代码（不灵活的）封装起来     —— 》nav.html

        {% include 'nav.html' %}

    7. 静态文件相关
        {% load static %}

        {% static 'css/pub.css'  %}        —— 》  去settings拿STATIC_URL，和css/pub.css拼接
                                           —— 》  /static/css/pub.css

        {% get_static_prefix %}            —— 》  去settings拿STATIC_URL

        {% get_static_prefix %}css/pub.css

    8. 自定义simple_tag和inclusion_tag

        1. 在app下创建templatetags的python包
        2. 在templatetags创建py文件  ——》 mytags.py
        3. 在mytags写代码
            from  django import template
            register = template.Library()

            @register.filter(name='dsb')
            def add_sb(value,arg):
                return  ....

            @register.simple_tag
            def add_sb(arg1,arg2,*args,**kwargs):
                return  ....


            @register.inclusion_tag('show_li.html')
            def show_li(n):
                return {'num': range(1, n + 1)}
        4. 在模板中使用
            {% load mytags %}

            {{ 变量|dsb：'canshu' }}

            {% add_sb '' ''  %}

            {% show_li 5 %}

今日内容：
    1. 视图

        1. CBV和FBV

            FBV (function based view)
            CBV (class based view )

            CBV写法：
                from django.views import View


                class AddPublisher(View):

                    def get(self, request):
                        print('这个是get')
                        return render(request, 'add_publisher.html')

                    def post(self, request):
                        print('这个是post')

                        return render(request, 'add_publisher.html', {"err_name": add_name, 'err_msg': err_msg})

            使用：
                url(r'^add_publisher/', views.AddPublisher.as_view()),
        2. CBV简单的流程：
            1. AddPublisher.as_view() ——》 view函数
            2. 当请求到来的时候才执行view函数
                1. 实例化AddPublisher  ——》 self
                2. self.request = request
                3. 执行self.dispatch(request, *args, **kwargs)
                    1. 判断请求方式是否被允许
                        handler = getattr(self, request.method.lower(), self.http_method_not_allowed)
                        通过反射获取对应的方法
                        GET  ——》  get
                        POST ——》  post

                    2. 执行获取到的方法  get(request,)  或者post(request,)
                    3. 得到HttpResponse对象，返回给self.dispatch
                4. 得到HttpResponse对象，返回django处理

        3. request
            request.method    ——》 请求的方式 8种  GET POST PUT DELETE OPTIONS
            request.GET       ——》 字典  url上携带的参数
            request.POST      ——》 字典  form表单通过POST请求提交的数据

            # print(request,type(request))
            # print(request.method)
            # print(request.GET)
            # print(request.POST)
            # print(request.path_info)
            # print(request.body)
            # print(request.scheme)
            # print(request.get_host())
            # print(request.get_full_path())
            # print(request.is_secure())

        4. response
            from django.shortcuts import render, HttpResponse ,redirect


            HttpResponse('字符串')             —— 》浏览器显示字符串
            render(request,'模板名字'，{})      —— 》返回一个完整的页面
            redirect(URL)                       —— 》跳转 重定向  location：url

        5. JsonResponse
            from django.http.response import JsonResponse

            JsonResponse（data）
            content_type： application/json



day72
内容回顾：
    1. 视图
        1. CBV 和 FBV
            CBV
                from django.views import View

                class AddPublisher(View):

                    def dispatch(self,request,*arg,**kwargs):
                        操作1
                        ret = super().dispatch(request,*arg,**kwargs)
                        操作2
                        return ret

                    def get(self,request,*arg,**kwargs):
                        pass

                    def post(self,request,*arg,**kwargs):
                        pass

            使用：
                url(r'^add_publisher/', views.AddPublisher.as_view()),

        2. CBV的流程
            1. views.AddPublisher.as_view() ——》 view函数
            2. 请求到来的时候执行view函数。
                1. 实例化AddPublisher，赋值给self
                    self.request = request
                2. 执行self.dispatch方法（AddPublisher如果有，执行自己的，没有的话执行View的）
                    判断请求是否被允许
                        允许：
                            通过反射获取到get或者post等方法
                        不允许：
                            拿到一个http_method_not_allowed方法
                3. 执行get或者post等方法，执行后得到一个HttpResponse对象

        3. 装饰的使用
            1. FBV的装饰器
                @装饰器

            2. CBV的装饰器：
                from django.utils.decorators import method_decorator


                1. 直接在方法上加：
                    @method_decorator(wapper)
                    def get(self, request)

                2. 给dispatch方法加
                    @method_decorator(wapper)
                    def dispatch(self, request, *args, **kwargs)

                3. 给类加
                    @method_decorator(wapper, name='post')
                    @method_decorator(wapper, name='get')
                    class AddPublisher(View)

        4. request
            request.method      请求方式 GET、POST PUT
            request.GET         url上的参数  ?id=1&name=alex   {'id':1,'name':'alex'}
            request.POST        POST请求提交的数据  {}
            request.path_info   URL路径   不包含域名端口和URL参数
            request.body        请求体
            request.FILES       上传的文件  {}  enctype="multipart/form-data"\

            request.get_host()  IP 端口
            request.ger_full_path()   URL路径   包含URL参数

        5. response  ——》HTTPResponse对象
            1. HttPResponse('字符串')          ——》  页面显示字符串的内容
                Content-Type : text/html;charset=utf8
            2. render(request,'模板文件名'，{})       ——》 返回一个完整的页面
            3. redirect('/index/')              跳转 重定向 Location:/index/
            4. JsonResponse(字典)     ——》 Content-Type : application/json

    2. 路由
        1.
            from django.conf.urls import url
            2.0   path re_path
            urlpatterns = [
                url(正则表达式，视图，参数，别名)，
                url(正则表达式，视图，参数，别名)，
                url(正则表达式，视图，参数，别名)，
                url(正则表达式，视图，参数，别名)，
            ]

        2. 正则表达式
            ^   开头
            $   结尾
            [0-9]  \d 数字
            ?   0次后1次
            + 一次多多次
            * 0次或多次

        3. 分组和命名分组


            url(r'book/[0-9]{4}/[0-9]{2}/$',book,)

            分组：
                url(r'book/([0-9]{4})/([0-9]{2})/$',book,)

                按照位置参数传递给视图函数

            命名分组：
                url(r'book/(?P<yaer>[0-9]{4})/(?P<month>[0-9]{2})/$',book,)

                按照关键字参数传递给视图函数
        4. 参数

            url(r'book/(?P<yaer>[0-9]{4})/(?P<month>[0-9]{2})/$',book,{‘year’：'1998' })



1.今日内容
    1. include

    2. url的命名和反向解析

        urls.py:

            url(r'^author_list/$', views.author_list, name='author_list'),

            url(r'^home/([0-9]{4})/([0-9]{2})/',views.home,name='home'),

            url(r'^home/(?P<year>[0-9]{4})/(?P<month>[0-9]{2})/',views.home,name='home'),
        视图中反向解析：

            from django.urls import reverse

            reverse('author_list')  ——》 '/author_list/'

            无名分组：
            reverse('home',args=('1999','06'))                     ——》'/home/1999/06/'

            有名分组

            reverse('home',kwargs={'year':'1998','month':'06'})    ——》'/home/1998/06/'



        模板中反向解析：
            {% url 'author_list' %}     ——》 '/author_list/'

            无名分组：
            {% url 'home' '2000' '09'  %}

            有名分组：
            {% url 'home' '2000' '09'  %}
            {% url 'home'  month='09' year='1898' %}







    3. ORM
        1. 命令
            python manage.py makemigrations   #   记录models的变更记录
            pyhton manage.py migrate          #   将变更记录同步到数据库中

        2. ORM
            models.Publisher

            pub_obj.id
            pub_obj.name

            book_obj.id
            book_obj.title
            book_obj.publisher       —— 》 关联的出版社对象
            book_obj.publisher_id    —— 》 关联的出版社对象的id
            book_obj.publisher.id
            book_obj.publisher.name


            author_ob.id
            author_ob.books         —— 》 管理对象
            author_ob.books.all()   —— 》 作者关联的所有书籍对象列表

            增：
                models.Publisher.objects.create(name='xxx')

                models.Book.objects.create(name='xxx',publisher=publisher_obj)
                models.Book.objects.create(name='xxx',publisher_id=publisher_obj.id)

                author_obj = models.Author.objects.create(name='xxxxx')
                author_obj.books.set([1,3,4])

            删除：
                对象列表.delete()
                对象.delete()

            修改：
                pub_obj.name='xxxxx'
                pub_obj.save()

                book_obj.title = 'xxxxx'
                book_obj.publisher =publisher_obj
                book_obj.publisher_id =publisher_obj.id
                book_obj.save()

                author_obj.name = 'xxx'
                author_obj.save()

                author_obj.books.set([1,3,4])



day74
1. 内容回顾
    1. ORM
        1. 13条
            1. 返回queryset的
                all()
                filter()
                exclude()
                order_by()
                reverse()
                distinct()
                values()
                values_list()
            2. 返回对象的
                get()
                first()
                last()
            3. 返回布尔值
                exists()
            4. 返回数字
                count()
        2. django使用mysql数据库的步骤
            1. 创建一个mysql数据库
            2. 配置
                DATABASES = {
                    'default': {
                        'ENGINE': 'django.db.backends.mysql',
                        'NAME': 'orm_homework',
                        'USER': 'root',
                        'PASSWORD': '',
                        'HOST': '127.0.0.1',
                        'PORT': 3306,
                    }
                }
            3. 告诉django使用pymysql连接你的mysql数据库（mysqldb）
                在与settings同级目录下的__init__.py中写
                import pymysql
                pymysql.install_as_MySQLdb()
            4. 在APP下的models.py中写类（继承Model）

            5. 执行数据库迁移的命令
                python manage.py makemigrations # 记录models的变更记录
                python manage.py migrate        # 将变更记录同步到数据库中


        2. 周末作业
            见代码
        3. OneToOneField(to='关联的表')  （一对一）
            在ForeignKey基础上加一个约束  unique=true

            1. 所有的内容可以写在一个表中
            2. 有的字段不常查，但有的字段查的很频繁
        4. 外键ForeignKey
            book_obj.publisher       ——》 关联的出版社对象
            book_obj.publisher_id

            反向查询：
                不指定related_name
                pub_obj.book_set    ——》关系管理对象
                指定related_name='books'
                pub_obj.books   ——》关系管理对象
        5. 多对多ManyToManyField
            book_obj.author
            多对多的方法：
                create()
                add()
                remove()
                set()
                clear()
        6. 单表的增删改查
            create
            delete
            update()
            .属性 = ''
            save()
        7. 进阶
            1. 聚合和分组
                aggregate   终止子句
                annotate
            2. F 和 Q

                ~取反
                & and
                | 或
            3. 事务

2. 今日内容
    0. 登录的实例


    1. cookie
        1. cookie是什么？
            cookie是保存在浏览器上一组组键值对

        2. 特性：
            1. 是服务器让浏览器设置的。浏览器有权利不设置。
            2. 访问其他页面的时候携带着cookie。

        2. 能干什么？
            1. 做登录



    2. session
        1. 保存在服务器上的键值对
        2. 一个cookie对应一个session
        流程：
            1. 给首次登录的用户设置一个cookie  session：asdasdasasdasdas
            2. 开辟一块空间存session
            3. session中存要存的数据（键值对）
            4. 返回给浏览器cookie

        # 设置session
        request.session['is_login'] = 'True'
        # 获取session
        request.session.get('is_login', '')

day75
内容回顾：
    1. cookie
        1. cookie是什么？
            服务器让浏览器保存在浏览器本地的键值对

        2. 为什么要有cookie？
            http是无状态，每次请求之间没有任何关系，无法保存状态。
        3. cookie的特点
            1. 服务器让浏览器设置的
            2. 设置之后每次访问相同的页面带上cookie
        4. django中操作cookie
            1. 设置cookie
                rep = redirect('/index/')
                rep.set_cookie(key,value,max_age=1000)
                rep.set_signed_cookie(key,value,max_age=1000,salt='')
            2. 获取cookie
                request.COOKIES['key']
                request.COOKIES.get('key')      ——》推荐的取法

                request.get_signed_cookie('key',salt='')

                request.method
                request.POST        ——》POST请求提交的数据  {}
                request.GET         ——》URL上的参数    /?id=11&name=xx
                request.FILES       ——》上传的文件
            3. 删除cookie
                rep.delete_cookie('key')
    2. session
        1.什么是session？
            session是保存在服务器上的键值对，依赖于cookie
        2. 为什么要有session？
            cookie在浏览器端 不太安全
            cookie长度受到限制
        3. django中操作session
            1. 设置session
                request.session['key'] = value
                request.session.setdefault(key,value)           ——》 存在就不设置
            2. 获取session
                request.session['key']
                request.session.get(key,'')
            3. 删除session
                request.session.pop(key)        ——》 删除某一个键值对
                del request.session['key']

                request.session.delete()        ——》删除所有的session键值对
                request.session.flush()         ——》删除所有的session键值对.删除了cookie
            4. 设置超时时间
                request.session.set_expiry()
            5. 清除当前过期的session
                request.session.clear_expired()

        4. session的其他的配置
            SESSION_COOKIE_NAME = 'sessionid'
            # Age of cookie, in seconds (default: 2 weeks).
            SESSION_COOKIE_AGE = 60 * 60 * 24 * 7 * 2
            # Whether to save the session data on every request.
            SESSION_SAVE_EVERY_REQUEST = False
            # Whether a user's session cookie expires when the Web browser is closed.
            SESSION_EXPIRE_AT_BROWSER_CLOSE = False

    3. 装饰器
        1. CBV加装饰器
            from django.utils.decorators import method_decorator
        2. 装饰器修复技术
            from functools import wraps
        3. csrf相关的装饰器
            from django.views.decorators.csrf import csrf_exempt,csrf_protect


2。今日内容
    1. 中间件
        1. 什么是中间件？
            中间件是一个类。用来处理Django的请求和响应的框架级别的钩子。
            中间件中定义方法。
        2. 五个方法：（process_request、process_response）
            process_request(self,request)
            process_view(self, request, view_func, view_args, view_kwargs)
            process_template_response(self,request,response)
            process_exception(self, request, exception)
            process_response(self, request, response)

            1. process_request
                1. 执行时间
                    在视图函数之前执行
                2. 参数
                    request 和视图中的request是同一个
                3. 返回值
                    返回None
                    返回response对象
                        不执行后面中间的process_request方法和视图
                        直接执行当前值中间件的process_response方法
                4. 执行顺序
                    按照注册的顺序执行


            2. process_response
                1. 执行时间
                    在视图函数之后执行
                2. request, response
                    request 和视图中的request是同一个
                    response 返回的response对象
                3. 返回值
                    返回response对象
                4. 执行顺序
                    按照注册的倒序执行

            3. process_view
                1. 执行时间
                    在视图函数之前，process_request之后执行
                2. 参数
                    view_func  将要执行的视图函数
                    view_args  视图函数的可变长位置参数
                    view_kwargs 视图函数的可变长关键字参数
                3. 返回值
                    返回  None  正常执行
                    返回  response对象   不执行后面的process_view和视图，直接执行所有中间件的process_response方法

                4。执行顺序
                    按照注册的顺序执行

            4. process_exception（有条件触发：有错误才执行）
                1. 执行时间
                    在视图函数之后，process_response之前执行
                2. 参数
                    exception  错误对象
                3. 返回值
                    返回  None  不对错误进行处理，交给下一个中间件进行处理
                    返回  response对象  下一个中间的process_exception不执行，直接执行所有中间件的process_response方法
                4. 执行顺序
                    按照注册的倒序执行
            5. process_template_response(条件触发：视图返回的response有render方法)
                1. 执行时间
                    在视图函数之后，process_response之前执行
                2. 参数
                3. 返回值
                    返回 response对象
                4. 执行顺序
                    按照注册的倒序执行，执行完所有的process_template_response方法后执行response.render方法
        3. 中间件的执行流程
            见博客中的图

        4. django请求的生命周期
            见博客中的图

3. 今日作业：
    1. 中间件版的登录验证
    2. 访问频率的限制（一分钟只能访问3次）


day76
1. 内容回顾
    1. 中间件
        Django的中间件是一个类。用来在全局范围内处理请求和响应。
    2. 五个方法
        1. process_request(self,request)
            参数：     request - 和视图中request一样 是请求相关的一个对象
            执行时间：   请求来先执行，在视图之前
            执行顺序：   按照注册顺序顺序执行
            返回值：
                    返回值是None   正常往后走
                    返回值是HTTPResponse对象   后面的不在走，直接执行当前中间件的process_response方法
        2. process_response(self,request,response)
            执行时间：   在视图之后
            执行顺序：   按照注册顺序倒序执行
            返回值：    HTTPResponse对象

        3. process_view(self,request,view_func,view_args,view_kwargs)
            执行时间：   在视图之前，process_request之后
            执行顺序：   按照注册顺序顺序执行
            返回值：
                None     正常往后走
                HTTPResponse对象  后面的中间件process_view方法、视图不执行，走所有中间的process_response方法
        4. process_exception（有条件触发：有错误才执行）
        5. process_template_response（条件触发：视图返回的response有render方法）
    3. 限制访问频率
        根据IP做判断，1分钟只能访问3次
            1. 获取ip
            2. 记录时间
            3. 根据访问记录做判断

2. 今日内容：
    1. ajax
        是一个异步与服务器交互的一种技术
    2. 优势：
        1. 异步：发一个请求之后不用等待响应，可以继续发下一个请求
        2. 偷偷的发请求，用户感受不到，不用刷新
        3. 数据量小，只需要想要的内容，不需要整个页面。
    3. 缺点：
        滥用技术，造成服务器压力过大

    4. 参数：
        $.ajax({
            url:'/calc/',       # 往哪里发送请求
            type:'post',        # 请求的方式
            data:{              # 发送的数据
                'i1':i1,
                'i2':i2
            },
            success:function (res) {        # 成功之后做什么事情
                console.log(res);           # res拿到的响应
                 $("#i3").val(res);
            }
        })

day77
1. 内容回顾
    1. json
        1. 是一种数据格式，不依赖于语言。
        2. python中数据类型的转化
            1. python对象 ——》 json字符串
                import json
                json.dumps(python的数据类型)
            2. json字符串 ——》python对象
                json.loads(json字符串)     # {}   ""

            3. 字符串 数字 布尔值 列表 字典 None

        3. JS中数据类型的转化
            1. JS对象  ——》json字符串
                var str = JSON.stringify(JS对象)

            2. json字符串 ——》  JS对象
                var o  =JSON.parse(json字符串)

            3. 字符串 数字 布尔值 数组 对象 null

    2. Ajax
        1. 向服务端发请求的方法：
            1. 在浏览器的地址栏上输入URL 回车            —— 》GET
            2. 使用form表单 提交                      —— 》 GET/POST
                1. action    # 提交的地址
                2. method    # 提交方式
                3. 上传文件的时候 enctype="multipart/form-data"
                4. input标签要有name属性
                5. 要有一个type=sumbit的按钮或者input
            3. a标签                                  —— 》GET
            4. Ajax
                1. 是js技术，向服务器发送异步请求。
                2. 如何使用jq来发送ajax请求：
                    导入 jquery
                    $.ajax({
                        url:'',
                        type:'post',
                        data:{},
                        success:function(res){
                            # res  服务器返回的响应
                        }
                    })
                3. django中通过csrf验证。
                    1. 在data中放"csrfmiddlewaretoken":
                    2. 加headers:
                        headers: {"X-CSRFToken":$("[name='csrfmiddlewaretoken']").val()},
                    3. 给全局ajax设置headers

                4. 上传文件
                    obj = New FormData()
                    obj.append('file',$("#f1")[0].files[0])
                    obj.append('name','xxx')

                    $.ajax({
                        url:'',
                        type:'post',
                        processData: false,  // 告诉jQuery不要去处理发送的数据
                        contentType: false,  // 告诉jQuery不要去设置Content-Type请求头
                        data:obj,
                        success:function(res){
                            # res  服务器返回的响应
                        }
                    })


2. 今日内容：
    1. 手写form
        1. 自己写HTML代码
        2. 对提交的数据进行校验
        3. 有错误信息的提示
    2. 使用django的form组件
        定义
        from django import forms
        class RegForm(forms.Form):
            username = forms.CharField()
            pwd = forms.CharField()
        后端使用：
            form_obj = RegForm()               # 没有数据的form对象
            form_obj = RegForm(request.POST)   # 有校验数据的form对象
            form_obj.is_valid()             # 对数据进行校验


        前端使用：
            {{ form_obj.as_p }}
            {{ form_obj.username }}                 ——》input标签
            {{ form_obj.username.label }}           ——》label的名字
            {{ form_obj.username.id_for_label }}    ——》input标签的id
            {{ form_obj.username.errors }}          ——》一个字段的所有错误信息
            {{ form_obj.username.errors.0 }}        ——》一个字段的第一个错误信息

            {{ form_obj.errors }}                   ——》所有字段的错误信息

    3. 字段类型和插件
        见博客

    4. 校验数据
        1. 内置的校验规则
            required=True,
            min_length=5,
            max_length=10,
        2. 自定制校验规则
            from django.core.validators import RegexValidator
            from django.core.exceptions import ValidationError

            def check(value):
                if "alex" in value:
                    raise ValidationError('含有非法字符')

            定义好后添加到字段的validators=[check,]

        3. 局部钩子
            定义clean_字段名
                正常通过校验：
                    返回该字段的值
                错误时：
                    抛出异常
        4. 全局钩子
            重写clean()方法
                正常通过校验：
                    返回self.cleaned_data
                错误时：

                    self.add_error('re_pwd', '两次密码不一致!!!!')
                    raise ValidationError("两次密码不一致")

day78
1. 内容回顾
    form组件
        1. form组件干的事：
            1. 自动生成input框
            2. 对提交的数据进行校验
            3. 有错误的信息
        2. 定义一个form组件
            from django import forms
            class RegForm(forms.Form):
                username = forms.CharField()
                pwd = forms.CharField()

        3. 使用
            后端使用：
                form_obj = RegForm()
                return render(request,'reg.html',{'form_obj':form_obj})

                form_obj = RegForm(request.POST)
                form_obj.is_vaild()

                form_obj.cleaned_data   ——》 字典  存放所有已经通过校验的字段和值

            前端使用：
                {{ form_obj.as_p }}              ——》生成所有的input框

                {{ form_obj.username }}          ——》username的input框
                {{ form_obj.username.label }}    ——》username的标签显示文字
                {{ form_obj.username.id_for_label }}    ——》input框的ID
                {{ form_obj.username.errors }}   ——》当前字段的所有错误
                {{ form_obj.username.errors.0   }}   ——》当前字段的第一个错误

                {{ form_obj.errors}}             ——》form表单的所有错误

        4. 字段类型和参数
            1.
                CharField()
                ChoiceField()
            2.  参数
                label       显示的文本
                initail     初识化的值
                min_length  最小长度
                max_length  最大长度
                required    是否必须
                error_messages = {"min_length":"太短了",'required': ""}
                widget  =  forms.widgets.PasswordInput(
                        attrs:{"class":"form_control"}
                    )
                validators = [验证器1,验证器2]
            3. 验证
                1. 内置的验证
                    min_length
                    max_length
                    required
                2. 自定义验证器
                    validators = [验证器1,验证器2]


                    from django.core.validators import RegexValidator
                    RegexValidator(r'1[3-9]\d{9}', '手机号不正经')

                    定义函数
                    def check(value):
                        if "alex" in value:
                            raise ValidationError('含有非法字符')

                3. 钩子函数
                    1. 局部钩子
                        clean_字段名(self):
                        通过校验：返回当前校验的值
                        不通过： raise ValidationError('不通过')
                    2. 全局钩子
                        clean(self):
                            通过校验：self.cleaned_data
                            不通过：
                                self.add_error('re_pwd', '两次密码不一致!!!!')
                                raise ValidationError('不通过')



2. 今日内容
    1. auth认证
        from django.contrib import auth

        1. 注册超级用户
            python manage.py createsuperuser
        2. 认证用户
            user_obj = authenticate(request, username=username, password=pwd)
        3. 保存登录状态
            写入到session中
            login(request,user_obj)

        4. 注销
            删除用户的session
            logout(request)
        5. 登录状态
            request.user.is_authenticated()

        6. login_required
            登录之后才能访问视图


        7. create_user()
        8. create_superuser()
        9. check_password(password)
        10. set_password(password)

        11. 扩展表
            from django.contrib.auth.models import AbstractUser
            class UserInfo(AbstractUser):
                """
                用户信息表
                """
                nid = models.AutoField(primary_key=True)
                phone = models.CharField(max_length=11, null=True, unique=True)


            # 引用Django自带的User表，继承使用时需要设置
            AUTH_USER_MODEL = "app名.UserInfo"

==============================================================

自己学习笔记django
form组件能干啥？
    1、自动生成input框
    2、校验提交的数据
    3、有错位的信息
    注： 只能生成form里面的内容，form标签需要自己建

定义一个form组件
1、 可在视图中创建，但最好在app下单独建立一个py文件，如myform.py
    1.1、导入form django import forms
    1.2、定义form类，继承forms.Form 或 froms.Models
    1.3、定义和数据库中没有关系的字段，也可以定义数据库中有的字段

    class MyForm(forms.Form):
        name = forms.Charfield()
        pwd = forms.Charfield()

注：前端浏览器做的校验，如果不需要，则在form标签上加novalidate属性

2、使用
    后端使用：views.py
    from app_name.myform import MyForm

    def view_func(request):

        form_obj = MyForm()   实例化

        if request.method == 'POSt':
            form_obj = MyForm(request.POST)   将接收到的数据传进去
            form_obj.is_vaild()     做校验，后台自动完成

            form_obj.cleaned_data    字典，已经通过校验的所有字段，没有通过，不会放入到里面

        return render(request, 'index.html' , {'form_obj': form_obj})



    前端使用：
        {{form_obj.as_p}}   所有的字段生成input框，每个input外面时p标签

            生成的html代码如下以as_p为例：
                <P>
                    <lable for='{{form_obj.name.id_for_label}}'>{{form_obj.name.label}}</lable>
                    <input>
                </p>

        {{form_obj.as_table/as_ui}}

        {{form_obj.name}}   name字段生成的input框，框的类型type和定义时charField定义有关

        {{form_obj.name.label}}    name的标签显示的文字，如用户名

        {{form_obj.name.id_for_label}}   input框的id，用于与label标签的for关联

        {{form_obj.name.errors}}    该字段后台验证返回来的所有的错误

        {{form_obj.name.errors.0}}    该字段后台验证返回来的所有的错误的第一个错误，所有的错误放在一个字典中

        {{form_obj.errors}}   form表单的所有的错误


    常用字段和参数
        1、字段
            CharField()      所有的字段都继承Field类，初始化都是TextFied，改变type都可以通过widget改变
            ChoiceField()

        2、参数
          label     显示的文本
          initail   初始化的值，默认值
          max_length/min_length    最长/短字符数
          required    是否必填
          help_text   在input框后的提示西信息
          err_messages = {"min_length": '太短了'，"required"： '此数字必须填写'}定义字段提示的错误

          widget = froms.widgets.PasswordInput(
                    attrs={'class':"form_contronl"}
          )     加插件，以改变input框的属性，可以加多个

          validators = [验证器1，]

        3、验证
            1、内置的验证
                max_length/min_length
                required
            2、自定义验证器
                方式一、
                from django.core.validators import RegexValidator  有很多类，这个是正则的验证
                RegexValidator(r'1[3-9]\d{9}', '手机号不符合规则')

                方式二、
                定义函数
                    def check(value):
                        if 'sex' in value:
                            raise ValidationError('含有非法字符')

                注：所有的验证器都是放在 validators 中，函数放在其中不用写括号


            3、利用钩子函数自定义验证
                钩子，框架级别的东西，流程过程中，预留一些空白，有，就进行验证，没有就过

                钩子函数，利用反射hasattr，拿到方法的字符串，有就执行，没有就过


                1、局部
                    clean_字段名（self）:
                        通过校验：返回当前校验的值   【for循环校验】
                        不通过:raise ValidationError('不通过')  报错

                        为什么报错？ 因为源码中通过try捕获到错误，放入到err_diact中，继续执行其它的程序

                2、全局: 所有的字段都校验完了，才回执行，里面只有通过的字段
                    clean(self)：
                        通过校验：返回 self.cleaned_data
                        不通过：
                        self.add_error('re_wd', '两次密码不一致')
                        raise ValidationError('不通过')  报错

====================================================================
auth组件

创建用户，验证登录

from django.contrib import auth

auth_user 表：
is_staff    是否是职员的状态,指定用户是否可以登录管理后台
is_active
is_superuser

创建超级管理员
python manage.py createsuperuser

认证用户
user_obj = auth.authenticate(request, username=username, password= password)

    认证通过，就返回一个user对象，错误就返回none

记录登录状态
    实际创建session， 故auth中间件，依赖session中间件，故session中间件注册顺序需在前，
    auth.login(request,user_obj)

注销，删除session
    auth.logout(request)

查看用户登录状态
    request.user.is_authenticaed()   返回false 或true

django登录认证装饰器
from django.contrib.auth.decorators import login_required

@login_required
def index(request):pass    直接加载视图上，就可以运行前先认证

    django默认当用户访问某一页面时，没有登录，则会跳转到登录url并且保存之前的url，等登录后跳转
    请求头：Location: /accounts/login/?next=/index/

    上面是默认要跳转到 /accounts/login/   故如果想用默认的必须url改成/accounts/login/
    这样的url设计不方便，故可以在setting中自己设置

    LOGIN_URL = '/login/'  # 这里配置成你项目登录页面的路由



'django.contrib.auth.middleware.AuthenticationMiddleware',
    没有登录就没有session，该中间件就返回一个匿名对象，为了解决调用方法不报错

request.user   主要是用于上面的中间件，进入到该中间件，
    主要定义了一个process_request()的方法，主要是在视图之前做的事

！！！！request.user 最后时返回一个user对象或匿名对象


from django.contrib import auth
创建普通用户：（注册示例）
def signup(request):
    re_form_obj = RegisterForm()
    if request.method == 'POST':
        re_form_obj = RegisterForm(request.POST)
        if re_form_obj.is_valid():   # 验证form对象， 而验证user表即auth表指定的字段，如账户秘密可以用 auth.authenticate(username=,password=,) 之所以要username，password是因为用的是默认的auth表，其中用户名和密码字段名分别为username，password
            # name = form_obj.cleaned_data.get('username')   # 验证通过后才能获取到字段
            # paw = form_obj.cleaned_data.get('password')
            # User.objects.create(username=name,password=pwd)  这种建立的是明文的密码，这种是无法登录的，因为django验证是按密文验证的，故需要用django提供的加密的方式创建用户，如下
            # User.objects.create_user(username=name,password=pwd)
            # 或
            User.objects.create_user(**form_obj.cleaned_data)  # 所有键值对字典打散，写入数据库

            扩展：注册完成之后，可以通过后台的方式，实现自动登录，如下代码
            user_obj = auth.authenticate(**form_obj.cleaned_data)
            auth.login(request，user_obj)  # 创建session
            return redirect('/index/')
            # 或则后台发json数据给前台，前台通过ajax接收，渲染到页面，实现自动登录和几秒中跳转


    return render(request, 'signup.html', {'re_form_obj':re_form_obj})


=======
CRM：customer Relationship Management  客户关系管理

1、需求分析
    1、CRM
        客户管理系统
    2、给谁用
        1、销售用
        2、老师用
    3、需求：
        1、登录
        2、注册
        3、销售
            3.1、增加/修改客户信息
            3.2、展示客户列表
                3.2.1、展示所有公户的信息
                3.2.2、展示销售私户的信息
            3.3、增加客户跟进记录
            3.4、展示某个客户的跟进记录
            3.5、添加缴费记录
            3.6、添加报名表
            3.7、公户转私户
            3.8、私户转公户
        4、老师
            4.1、展示老师所带班级的信息
            4.2、展示所有课程记录（某天上什么课，作业）
            4.3、学生上课记录

表的设计：
学生表
老师表
销售表
课程表